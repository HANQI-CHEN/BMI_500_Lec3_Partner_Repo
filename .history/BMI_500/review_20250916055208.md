# Review for `leibniz.py`
----------
## Human Review
Original Code:
```python
def leibniz_pi(n)
    pi = 0
    for i in range(n):
        pi += ((-1) ** i) / (2 * i)
    print(pi * 4
    return pi * 4
```
Fixed Code:
```python
from math import pi

def leibniz_pi (n:int):
    """
    n : Number of terms to include (n >= 1, int)

    Returns: Approximate pi (float)
    """
    if n <= 0:
        return 0.0
    
    pi = 0.0
    for k in range(n):
        pi += ((-1.0)**k) / (2.0 * k + 1.0)

    print(pi * 4)
    return pi * 4
```
Need to fix:
1. Define `pi` inside code (don’t import from `math`).
2. Add missing `:` after `def` and fix the `print` line.
3. Leibniz series term is written wrong, should be `(2*i + 1)` in denominator.
4. Does not handle negative input properly.

Improvment:
1. Added n: int in the function signature.
2. Updated the docstring comment to clearly explain the function’s ability.

Time Complexity: O(n)

-----------
## LLM review
LLM: **ChatGpt 5**
Prompt: `Please review this code, find its potential errors, and review it from the perspective of an SDE concerned, and return your review in the MD cell, and keep it condensed`

### LLM Review:
#### Summary
The function aims to approximate π via the Leibniz series, but has multiple **syntax**, **runtime**, and **correctness** issues. Below are concise findings and a fixed, SDE-grade implementation.

---

#### Bugs / Errors
- **Syntax:** Missing `:` after `def`; missing `)` in `print(...)`.
- **Runtime:** `1/(2*i)` divides by zero at `i = 0`.
- **Math correctness:** Leibniz term is `(-1)^i / (2*i + 1)`, not `/ (2*i)`.
- **Side effects:** Printing inside the function mixes I/O with computation.
- **Shadowing:** Variable name `pi` can confuse with `math.pi`.
- **Type safety:** No guard for non-int/negative `n`.

---

#### Design & Maintainability
- Add **type hints** and a **docstring**.
- Separate **concerns**: compute vs. print.
- Prefer **iterators** + `math.fsum` for better numerical summation.
- Avoid `(-1)**i` (slow, unclear). Use a sign flip.

---

#### Performance & Numerical Notes
- Time complexity **O(n)**; the series converges **very slowly** (millions of terms needed for modest precision).
- Use **pairwise/compensated** summation (e.g., `math.fsum`) to reduce floating-point error for large `n`.
- If high performance is required, consider **alternatives** (e.g., Machin-like formulas, arctan identities, or libraries).

---

#### Testing Suggestions
- Unit tests: `n=0 -> 0.0`, `n=1 -> 4.0`, monotonic partial sums alternate around `math.pi`.
- Property tests: increasing `n` should reduce absolute error on average.
- Input validation tests: negative `n` and non-ints raise `ValueError/TypeError`.

---

#### Fixed Implementation (concise)
```python
import math
from math import fsum
from typing import Iterable

def _leibniz_terms(n: int) -> Iterable[float]:
    """Yield n terms of the Leibniz series for π/4."""
    if n < 0:
        raise ValueError("n must be non-negative")
    sign = 1.0
    for i in range(n):
        yield sign / (2*i + 1)
        sign = -sign

def leibniz_pi(n: int) -> float:
    """Approximate π using the first n Leibniz terms."""
    return 4.0 * fsum(_leibniz_terms(n))
